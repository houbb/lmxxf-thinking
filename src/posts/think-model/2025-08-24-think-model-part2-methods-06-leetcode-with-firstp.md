---

title: 第一性原理在 leetcode 中的实战
date: 2025-08-24
categories: [Think-Model]
tags: [think-model, thinking, sh]
published: true
---


# 背景

力扣题目动不动就几千题，我们全部刷一遍不现实。

刷了忘记，每个题目不同还是会在掉坑里。

如何通过 第一性原理 来分析如何刷题？如何解决问题呢？

痛点是：LeetCode 题量巨大 → 刷题效率低 → 容易忘题 → 每道题似乎都不同 → 很容易掉坑。

# 通过第一性原理分析刷题问题

用第一性原理来分析刷题问题，可以帮你找到本质解决方案，而不是机械刷题。

## 一、回到问题本质

### 1. 为什么刷题？

* 表面目标：刷题提升算法和编码能力
* 第一性问题：

  1. 技能提升：学习算法思想、数据结构应用、问题分析能力
  2. 思维训练：训练逻辑拆解、抽象能力、解决问题思维
  3. 经验积累：形成解题模板，减少未来遇到类似题的认知负担

> 核心不是刷“数量”，而是技能和思维的沉淀。

### 2. 刷题难点分析

* 数量巨大 → 不可能全部刷
* 忘记题目 → 记忆不系统
* 每题不同 → 不知道复用哪种思路
* 掉坑 → 缺少解题框架

用第一性原理拆解：

1. 目标 = 技能提升 + 思维训练 + 模板积累
2. 障碍 = 题量大、知识碎片化、记忆难、缺乏结构
3. 问题本质 = 如何用最少的题量获得最大能力提升？

---

## 二、用第一性原理思考刷题策略

### 1. 明确能力要素

把刷题能力拆解到底层“原子技能”：

* 算法思维：DFS/BFS、二分查找、动态规划、贪心、分治
* 数据结构能力：数组、链表、栈、队列、哈希表、堆、树、图
* 逻辑结构化：问题分析 → 分类 → 拆解 → 实现
* 代码能力：快速实现 + 边界处理 + 时间复杂度优化

> 结论：刷题本质是能力训练，而不是刷题量。

### 2. 构建题型映射

用最小题量覆盖能力：

* 按 数据结构 × 算法 建立矩阵
* 每个“格子”选 1\~2 道代表题
* 例：

```
          DFS  BFS  DP  Greedy
Array     -    -    1    1
Linked    1    -    -    -
Tree      1    1    1    -
Graph     1    1    -    -
Heap      -    -    -    1
```

> 核心思想：最少题量覆盖全部技能点

### 3. 模板化

* 每类题型形成解题模板：

  * 输入 → 数据结构 → 算法 → 边界 → 输出
* 遇到新题 → 套用模板 → 快速解题
* 第一性原则：把复杂题目降解到最小不可分解元素 → 模板化

### 4. 复盘与归纳

* 每题做完，不只关注是否 AC
* 归纳：

  * 算法思想
  * 数据结构使用
  * 边界处理和优化
* 形成自己的知识库
* 第一性原则：把每道题的知识抽象为最本质的规律，而不是单题记忆

---

## 三、刷题实践策略

1. 优先高价值题

   * 根据第一性原理：选择最能覆盖能力点的题，而非数量
   * 例如：Two Sum、三数之和、最大子数组和 → 覆盖数组 + 哈希/双指针 + 贪心/前缀和

2. 模板化解题

   * 每类算法/数据结构 → 形成标准模板
   * 新题先匹配模板，再调整细节

3. 高频题复盘

   * 用 EMCE 或矩阵方式归类
   * 定期复盘，强化记忆 → 防止遗忘

4. 反思与优化

   * 对复杂题拆解原因 → 哪些技能点未掌握
   * 第一性原则 → 聚焦能力缺口，不盲刷

---

## 四、总结

* 刷题的第一性目标：训练算法思维 + 数据结构能力 + 模板化解决问题
* 本质问题：不是题量，而是如何最大化能力沉淀
* 解决方案：

  1. 按能力拆解 → 建立题型覆盖矩阵
  2. 模板化 → 套用解题框架
  3. 归纳复盘 → 形成系统知识库
  4. 定期复盘 → 防止遗忘、优化技能

> 核心思路：回到本质，刷题不刷量，而刷“能力 + 模板 + 系统”



